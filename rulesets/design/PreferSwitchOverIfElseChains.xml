<?xml version="1.0" ?>
<ruleset
	name="Apex Design Rules"
	xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd"
>
	<description>
		Custom rules for Apex design issues (structure, method signatures, class
		organization)
	</description>
	<rule
		name="PreferSwitchOverIfElseChains"
		language="apex"
		message="If-else chains, consecutive if statements, or OR conditions comparing the same variable should use switch statements instead for better readability and performance"
		class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
	>
		<description>
			If-else chains, consecutive if statements, OR conditions, or any
			combination of these patterns with a minimum number of conditions that
			compare the same variable should use switch statements instead. This detects
			patterns like: if (x == 'a') {} else if (x == 'b') {} else if (x == 'c') {}
			or consecutive if statements: if (x == 'a') {} if (x == 'b') {} if (x ==
			'c') {} or OR conditions: if (x == 'a' || x == 'b' || x == 'c') {} or mixed
			patterns: if (x == 'a' || x == 'b') {} if (x == 'c') {} else if (x == 'd')
			{} if (x == 'e') {} The rule counts all conditions comparing the same
			variable across all if statements in a method, not just within a single
			chain. Switch statements are more readable and can be more performant than
			long if-else chains, multiple consecutive if statements, or complex OR
			conditions.
			
			Note: This rule only applies when all conditions compare the same
			variable/expression using equality (==) or instanceof checks, and the
			variable type is compatible with switch statements. Supported types
			include:
			- Integer, Long, String (primitive types)
			- Enum (user-defined enumerated types)
			- SObjectType, Schema.SObjectType (Salesforce object type tokens)
			- SObject (Salesforce object instances - when the type is extracted
			using getSObjectType() and compared)
			
			Other types like Boolean, Decimal, Date, DateTime, Time, Id, Blob, etc.
			are not flagged as they cannot be used in switch statements.
			
			For SObject instances, the rule detects two common patterns:
			1. When developers extract the SObjectType using getSObjectType() and
			compare it in if-else chains
			2. When developers use instanceof checks to determine the sObject type
			
			Both patterns can be refactored to use a switch statement directly on
			the sObject instance, which provides automatic type casting in the when
			clauses (as shown in the Salesforce Apex documentation). The instanceof
			pattern is particularly common and can be replaced with cleaner switch
			syntax.
			
			To customize this rule, edit the $minConditions variable at the beginning
			of the XPath expression (default: 2). This sets the minimum number of
			conditions comparing the same variable required before a switch statement is
			recommended.

			Version: 1.1.0
		</description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
					<![CDATA[
					let $minConditions := 2,
						$switchTypes := (
							'Integer', 'Long', 'String', 'SObject', 'SObjectType',
							'Schema.SObjectType'
						),
						$isSwitchCompatibleType := function($varDecl, $context) {
							$varDecl/@Type = $switchTypes
							or exists(
								$context/ancestor::ApexFile//UserEnum[@Image = $varDecl/@Type]
							)
						},
						$getVarDecl := function($varName, $method) {
							(
								$method//VariableDeclaration[
									VariableExpression/@Image = $varName
								]
								| $method/Parameter[@Image = $varName]
							)[1]
						},
						$countStandaloneConditions := function($varName, $method) {
							let $allStandaloneIfBlocks := $method//IfBlockStatement[
								not(ancestor::IfElseBlockStatement)
							]
							return sum(
								for $block in $allStandaloneIfBlocks
								return (
									if (exists(
										$block/StandardCondition/BooleanExpression[@Op='||']
									)) then
										count(
											$block/StandardCondition//BooleanExpression[
												@Op='=='
												and VariableExpression/@Image = $varName
											]
										)
									else if (
										$block/StandardCondition/BooleanExpression[@Op='==']
										/VariableExpression/@Image = $varName
									) then
										1
									else
										0
								)
							)
						},
						$countChainConditions := function($varName, $method) {
							let $allIfElseChains := $method//IfElseBlockStatement
							return sum(
								for $chain in $allIfElseChains
								return (
									if (
										count(
											$chain/IfBlockStatement[
												StandardCondition/BooleanExpression[@Op='==']
												/VariableExpression/@Image = $varName
											]
										) = count($chain/IfBlockStatement)
										and count($chain/IfBlockStatement) > 0
									) then
										count($chain/IfBlockStatement)
									else
										0
								)
							)
						},
						$countInstanceofConditions := function($varName, $method) {
							count(
								$method//IfBlockStatement[
									StandardCondition/InstanceOfExpression
									/VariableExpression/@Image = $varName
								]
							)
						}
					return (
						//IfElseBlockStatement[
							let $firstVar := IfBlockStatement[1]
								/StandardCondition/BooleanExpression[@Op='==']
								/VariableExpression/@Image,
								$method := ancestor::Method[1],
								$varDecl := $getVarDecl($firstVar, $method),
								$chainConditions := count(IfBlockStatement),
								$standaloneConditions := $countStandaloneConditions(
									$firstVar,
									$method
								),
								$totalConditions := $chainConditions + $standaloneConditions
							return $chainConditions >= $minConditions
								and count(
									IfBlockStatement[
										StandardCondition/BooleanExpression[@Op='==']
										/VariableExpression
									]
								) = count(IfBlockStatement)
								and count(
									IfBlockStatement[
										StandardCondition/BooleanExpression[@Op='==']
										/VariableExpression/@Image = $firstVar
									]
								) = count(IfBlockStatement)
								and exists($varDecl)
								and $isSwitchCompatibleType($varDecl, .)
								and (
									$totalConditions >= $minConditions
									or $chainConditions >= $minConditions
								)
						]
						|
						//IfBlockStatement[
							StandardCondition/BooleanExpression[@Op='==']
							/VariableExpression
							and not(ancestor::IfElseBlockStatement)
							and not(
								preceding-sibling::*[1][self::IfBlockStatement[
									not(ancestor::IfElseBlockStatement)
									and StandardCondition/BooleanExpression[@Op='==']
									/VariableExpression/@Image =
									./StandardCondition/BooleanExpression[@Op='==']
									/VariableExpression/@Image
								]]
							)
							and (
								let $var := StandardCondition/BooleanExpression[@Op='==']
									/VariableExpression/@Image,
									$method := ancestor::Method[1],
									$varDecl := $getVarDecl($var, $method),
									$standaloneConditions := $countStandaloneConditions(
										$var,
										$method
									),
									$chainConditions := $countChainConditions(
										$var,
										$method
									),
									$totalConditions := $standaloneConditions
										+ $chainConditions
								return exists($varDecl)
									and $isSwitchCompatibleType($varDecl, .)
									and $totalConditions >= $minConditions
							)
						]
						|
						//IfBlockStatement[
							StandardCondition/BooleanExpression[@Op='||']
							and (
								let $eqComparisons := StandardCondition//BooleanExpression[
									@Op='==' and VariableExpression
								],
									$firstVar := $eqComparisons[1]/VariableExpression/@Image,
									$method := ancestor::Method[1],
									$varDecl := $getVarDecl($firstVar, $method)
								return count($eqComparisons) >= $minConditions
									and count(
										$eqComparisons[
											VariableExpression/@Image = $firstVar
										]
									) = count($eqComparisons)
									and exists($varDecl)
									and $isSwitchCompatibleType($varDecl, .)
							)
						]
						|
						//IfElseBlockStatement[
							let $firstInstanceof := IfBlockStatement[1]
								/StandardCondition/InstanceOfExpression
								/VariableExpression/@Image,
								$method := ancestor::Method[1],
								$varDecl := $getVarDecl($firstInstanceof, $method),
								$chainConditions := count(
									IfBlockStatement[
										StandardCondition/InstanceOfExpression
										/VariableExpression/@Image = $firstInstanceof
									]
								)
							return $chainConditions >= $minConditions
								and $chainConditions = count(IfBlockStatement)
								and exists($varDecl)
								and $varDecl/@Type = 'SObject'
						]
						|
						//IfBlockStatement[
							StandardCondition/InstanceOfExpression/VariableExpression
							and not(ancestor::IfElseBlockStatement)
							and (
								let $var := StandardCondition/InstanceOfExpression
									/VariableExpression/@Image,
									$method := ancestor::Method[1],
									$varDecl := $getVarDecl($var, $method),
									$instanceofConditions := $countInstanceofConditions(
										$var,
										$method
									)
								return exists($varDecl)
									and $varDecl/@Type = 'SObject'
									and $instanceofConditions >= $minConditions
							)
						]
					)
					]]>
				</value>
			</property>
		</properties>
		<example>
			<![CDATA[
			// Violation: If-else chain with 2+ conditions
			if (status == 'active') {
			    // ...
			} else if (status == 'inactive') {
			    // ...
			} else if (status == 'pending') {
			    // ...
			}
			
			// Valid: Use switch statement instead
			switch on status {
			    when 'active' {
			        // ...
			    }
			    when 'inactive' {
			        // ...
			    }
			    when 'pending' {
			        // ...
			    }
			}
			]]>
		</example>
		<example>
			<![CDATA[
			// Violation: Consecutive if statements comparing same variable
			if (status == 'active') {
			    // ...
			}
			if (status == 'inactive') {
			    // ...
			}
			if (status == 'pending') {
			    // ...
			}
			
			// Valid: Use switch statement instead
			switch on status {
			    when 'active' { }
			    when 'inactive' { }
			    when 'pending' { }
			}
			]]>
		</example>
		<example>
			<![CDATA[
			// Violation: OR conditions with 2+ comparisons
			if (status == 'active' || status == 'inactive' || status == 'pending') {
			    // ...
			}
			
			// Valid: Use switch statement instead
			switch on status {
			    when 'active', 'inactive', 'pending' {
			        // ...
			    }
			}
			]]>
		</example>
		<example>
			<![CDATA[
			// Valid: Boolean comparisons are not flagged (cannot use switch)
			if (isActive == true || isActive == false) {
			    // ...
			}
			
			// Valid: Different variables are not flagged
			if (status == 'active') {
			    // ...
			} else if (type == 'premium') {
			    // ...
			}
			]]>
		</example>
		<example>
			<![CDATA[
			// Violation: Enum type with if-else chain
			MyEnum status = MyEnum.VALUE1;
			if (status == MyEnum.VALUE1) {
			    // ...
			} else if (status == MyEnum.VALUE2) {
			    // ...
			} else if (status == MyEnum.VALUE3) {
			    // ...
			}
			
			// Valid: Use switch statement instead
			switch on status {
			    when MyEnum.VALUE1 {
			        // ...
			    }
			    when MyEnum.VALUE2 {
			        // ...
			    }
			    when MyEnum.VALUE3 {
			        // ...
			    }
			}
			]]>
		</example>
		<example>
			<![CDATA[
			// Violation: SObjectType with if-else chain
			Schema.SObjectType objType = Account.sObjectType;
			if (objType == Account.sObjectType) {
			    // ...
			} else if (objType == Contact.sObjectType) {
			    // ...
			} else if (objType == Opportunity.sObjectType) {
			    // ...
			}
			
			// Valid: Use switch statement instead
			switch on objType {
			    when Account.sObjectType {
			        // ...
			    }
			    when Contact.sObjectType {
			        // ...
			    }
			    when Opportunity.sObjectType {
			        // ...
			    }
			}
			]]>
		</example>
		<example>
			<![CDATA[
			// Violation: SObject instance - extract type first, then compare
			SObject record = getRecord();
			Schema.SObjectType recordType = record.getSObjectType();
			if (recordType == Account.sObjectType) {
			    Account acc = (Account) record;
			    // ...
			} else if (recordType == Contact.sObjectType) {
			    Contact con = (Contact) record;
			    // ...
			} else if (recordType == Opportunity.sObjectType) {
			    Opportunity opp = (Opportunity) record;
			    // ...
			}
			
			// Valid: Use switch statement directly on sObject instance
			switch on record {
			    when Account acc {
			        // acc is automatically cast to Account type
			        // ...
			    }
			    when Contact con {
			        // con is automatically cast to Contact type
			        // ...
			    }
			    when Opportunity opp {
			        // opp is automatically cast to Opportunity type
			        // ...
			    }
			    when else {
			        // handle other sObject types
			    }
			}
			]]>
		</example>
		<example>
			<![CDATA[
			// Violation: SObject instanceof pattern with if-else chain
			SObject sobject = getRecord();
			if (sobject instanceof Account) {
			    Account a = (Account) sobject;
			    System.debug('account ' + a);
			} else if (sobject instanceof Contact) {
			    Contact c = (Contact) sobject;
			    System.debug('contact ' + c);
			} else if (sobject instanceof Opportunity) {
			    Opportunity o = (Opportunity) sobject;
			    System.debug('opportunity ' + o);
			} else {
			    System.debug('default');
			}
			
			// Valid: Use switch statement directly on sObject instance
			switch on sobject {
			    when Account a {
			        // a is automatically cast to Account type
			        System.debug('account ' + a);
			    }
			    when Contact c {
			        // c is automatically cast to Contact type
			        System.debug('contact ' + c);
			    }
			    when Opportunity o {
			        // o is automatically cast to Opportunity type
			        System.debug('opportunity ' + o);
			    }
			    when null {
			        System.debug('null');
			    }
			    when else {
			        System.debug('default');
			    }
			}
			]]>
		</example>
	</rule>
</ruleset>
